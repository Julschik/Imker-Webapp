TITLE: Imker-Webapp v3 – Offline-first, QR-first, self-hosted Backend

GOAL
Offline-first Webapp für Hobby- und Berufsimker. Kernfluss: QR→Stockkarte→Aktion ≤2 Klicks. Rechtssichere Daten. Saubere Exporte. Klare Sperr-/Warnlogik. Robuste Sync.

AUDIENCE
Semi- bis Profi-Imker. Nutzenorientiert. Zeitersparnis. Transparenz. Compliance.

SCOPE v1.0 (MVP)
- Module: Dashboard, Standorte, Völker/Stockkarten, Durchsichten, Bestandsbuch (TAMG), Fütterung, Ernte & Lose, Wanderung, Proben/Analytik, Lager, Behörden/TSK, Dokumente, Kalender/Reminder, Wiki/Hilfe, Einstellungen/Rollen.
- Offline nutzbar für alle Kernvorgänge. Delta-Sync online.
- Konflikte: Feldweises LWW. Kritische Datensätze (Behandlung/Ernte/Los) mit einfachem Merge-Dialog.
- Rollen: workspace-weit Admin/Editor/Viewer.
- Sicherheit: E-Mail/Passwort + TOTP 2FA.
- Nicht enthalten: Objekt-ACL, E2E-Feldverschlüsselung, Gamification.

ARCHITEKTUR
Frontend
- Next.js App Router + TypeScript + Tailwind + shadcn/ui.
- PWA: Service Worker, Manifest. IndexedDB (Dexie) als Primärspeicher.
- Routen je Modul. Code-Splitting. Virtuelle Tabellen.

Backend (Referenz, self-hosted, kein Lock-in)
- Fastify (Node) + Postgres + MinIO (S3) + Keycloak/Ory.
- REST-ABI: `/sync/pull?cursor`, `/sync/push`, `/files/sign` (PUT/GET), `/export/pdf`, `/ics/{workspace}/{token}`, `/public/*`.
- Alternative Adapter: Supabase (DB/Auth/Storage/Edge) mit identischer REST-ABI. Umschaltbar via `.env`.

UPLOAD/DOWNLOAD FLOW
- `FileRef { id, storageKey, mime, bytes, sha256, createdAt, signedUrl? }`.
- Upload bevorzugt direct-to-storage: `POST /files/sign {storageKey,mime,bytes,sha256}` → pre-signed PUT. Client lädt hoch. `POST /files/confirm {id,sha256}`.
- Fallback: `POST /files/upload` multipart an Backend.
- Download: `GET /files/sign?id` liefert `signedUrl` (TTL 15 min). Keine öffentlichen Buckets.

SYNC
- Client speichert lokal alle Entitäten. Soft-deletes. Serverzeitstempel.
- Push: Batch mit idempotencyKey. Pull: geordnete Changes ab Cursor.
- Konfliktindikatoren im UI. Kritische Diffs wählbar je Feld.

SCAN & IDENTIFIKATION
- Screen „Scannen“ hat Tabs:
  1) QR (Default): Kamera-Live. Treffer auf `qrKey` → Deep-Link.
  2) NFC: erscheint nur, wenn `navigator.nfc` verfügbar. Fehler → Toast → Auto-Rückfall zu QR.
  3) Manuell: Suchfeld für Stock-Nr./QR-Key.
- Web Share zum Teilen von Deep-Links.

ÖFFENTLICHE STECKBRIEFE
- Opt-in pro Volk/Los → `publicId`. Route: `/p/{publicId}` vom Backend. Read-only. Minimalfelder. `Cache-Control` kurz. `robots:noindex`. Standort optional gerundet (z. B. 2 Dezimalen) oder ausgeblendet. Snapshot-Export optional für statisches Hosting.

PROVIDER-INTERFACES
- WetterProvider: Open-Meteo (Default), austauschbar.
- TranskriptProvider: Whisper lokal oder OpenAI Whisper. Roundtrip über `FileRef`.
- SperrbezirkProvider: GeoJSON-Upload via Admin-UI. Standort-Check gegen Layer. Link zur Quelle speicherbar pro Layer.

DATENMODELL (fachlich)
Common
- Address { strasse, plz, ort, land }
- Geo { lat, lng, geohash? }

User { id, email, name, roles[], twofaEnabled }
Workspace { id, name }
Membership { userId, workspaceId, role }

Standort { id, workspaceId, name, address:Address, geo:Geo, wasserquelle?, genehmigungen:FileRef[], tags[], qrKey?, nfcUid? }

Queen { id, workspaceId, year, marking?, origin?, notes? }
QueenEvent { id, volkId, queenId, von, bis?, grund? } // Historie
Volk { id, workspaceId, stocknr, standortId, beute, rahmenmass, herkunft?, koeniginId?:Queen.id, status{brut,futter,varroa,platz}, tags[], qrKey?, nfcUid? }

Durchsicht { id, volkId, datum, checks{königin,stifte,larven,verdeckelte}, pollen?, futter?, verhalten?, wabenZaehlen{brut,futter,leer}, volksstaerke(0-10), sprachmemoFile?:FileRef.id, transkriptFile?:FileRef.id, followUps[] }

Behandlung (TAMG)
{ id, scope{volkId?|standortId?|workspace}, datum, praep, wirkstoff, charge?, dosis, methode?, wartezeitTage, behandler, quelle?, belegRef?:FileRef.id, sperrBis }

Fütterung { id, volkId?|standortId?, datum, futtertyp, menge_kg, methode?, anlass? }

Ernte { id, standortId?|volkId?, datum, honigraeume, kg, wassergehalt, notiz? }
Los { id, name, zeitraum{von,bis}, standorte:standortId[], analytik{wasser?,HMF?,diastase?}, mhd,
  etikettenfelder{
    verkehrsbez:"Honig", sorte?, herkunft, fuellmenge_g, mhd, loscode,
    inverkehrbringer{ name, adresse:Address },
    zusatzfelder{ [key]:string[] }
  },
  oeffentlich?:boolean, publicId?:string
}
HarvestLotAlloc { harvestId, lotId, kg }

GlaeserMapping { id, lotId, jar_ml, deckel_typ, anzahl, serial_start?, serial_end? }

Probe { id, typ["honig"|"bienen"], datum, labor?, werte{...}, resultat?, grenzwertCheck? }

Wanderung { id, vonStandortId, zuStandortId, zeitraum{von,bis}, tracht?, genehmigungRef?:FileRef.id, gesundheitszeugnisse:FileRef[], sperrbezirkCheck{status, details?} }

Lager
- FutterwabeBatch { id, standortId?, anzahl, gereinigt:boolean }
- EinschmelzBatch { id, typ, gewicht_kg, seuchenstatus }
- WachsBatch { id, art["eigen","zukauf","mittelwand"], gewicht_kg, entseucht:boolean, charge?, mhd? }
- BeutenteilBatch { id, teil, zustand, menge }
- HonigVorrat { id, lotId, menge_kg, mhd }

BehoerdenTSK
- Registrierung { id, nr, dokument?:FileRef.id }
- Stichtagsmeldung { id, jahr, erstelltAm, exportFile?:FileRef.id }
- Aenderungsmeldung { id, datum, altBestand, neuBestand, exportFile?:FileRef.id }
- Seuchenfall { id, datum, meldungRef?:FileRef.id, befundRef?:FileRef.id, sperrbezirkGeo?:FileRef.id }

Dokument { id, typ, file:FileRef, bezuege{ entity:string, id:string }[] }

KalenderEvent { id, typ, start, ende?, scope["workspace"|"standort"|"volk"], sourceEntity? }

WikiArtikel { id, title, markdown, tags[], version, reviewedBy?, kontextregeln?[] }

COMPLIANCE
- TAMG Bestandsbuch vollständig. Wartezeit-Sperre blockiert Ernte/Lose bis `sperrBis`.
- TSK: Stichtag 01.01., Frist 14.01. Änderungsmeldung bei >20 % und ≥10 Völkern.
- Gesundheitszeugnisse: Upload, Ablaufwarnung.

UX RULES
- Mobile first. Große Touchziele. Ampeln. Segment-Buttons statt Freitext.
- Fehlermeldungen kurz, handlungsleitend.
- Scan→Stockkarte→Aktion ≤2 Klicks.

ANALYTIK
- Ertrag je Volk/Stand/Saison. Medikamenteneinsatz. Varroa-Kurven + Wirksamkeit. Jahresvergleich.
- Export PNG/PDF.

KALENDER & ICS
- In-App Kalender. ICS per Backend: `/ics/{workspaceId}/{token}`. Token revokable.

EXPORTS
- CSV/JSON je Modul. PDF: Bestandsbuch, Stichtags-/Änderungsmeldung, Etikettendaten.

SECURITY & PRIVACY
- EU-Hosting möglich. TLS. At-Rest-Verschlüsselung im Storage.
- Rollen Admin/Editor/Viewer. Objekt-ACL Phase 2.
- E2E für sensible Dokumente Phase 2.

AKZEPTANZ (Stichproben)
- Offline Durchsicht inkl. Audio → Transkript import → Folgeaufgaben erzeugt.
- Behandlung setzt `sperrBis` → Ernte/Los gesperrt bis Datum.
- Wanderung Multi-Scan → Sperrbezirk-Warnung mit GeoJSON-Layer.
- Ernte↔Los über Allokation → Etikettendaten-Export → GläserMapping erfasst.
- ICS abonnierbar. Sync-Konflikt auf kritischem Datensatz lösbar.

ENTWICKLUNGSUMGEBUNG (Tooling)
- Zustand, RHF+Zod, Dexie. Tests: Vitest, Playwright. Lint/Format: ESLint/Prettier.
- PDF serverseitig (Fastify). Client-Fallback optional.
- ENV: `BACKEND_PROVIDER ∈ {selfhosted,supabase}`, `SIGNED_URL_TTL_MIN`, `PUBLIC_COORD_PRECISION`.
